<!DOCTYPE html>
<html>
  <body>
    <script>
      "use strict";

      (function() {
        function toArray(arr) {
          return Array.prototype.slice.call(arr);
        }

        function promisifyRequest(request) {
          return new Promise(function(resolve, reject) {
            request.onsuccess = function() {
              resolve(request.result);
            };

            request.onerror = function() {
              reject(request.error);
            };
          });
        }

        function promisifyRequestCall(obj, method, args) {
          var request;
          var p = new Promise(function(resolve, reject) {
            request = obj[method].apply(obj, args);
            promisifyRequest(request).then(resolve, reject);
          });

          p.request = request;
          return p;
        }

        function promisifyCursorRequestCall(obj, method, args) {
          var p = promisifyRequestCall(obj, method, args);
          return p.then(function(value) {
            if (!value) return;
            return new Cursor(value, p.request);
          });
        }

        function proxyProperties(ProxyClass, targetProp, properties) {
          properties.forEach(function(prop) {
            Object.defineProperty(ProxyClass.prototype, prop, {
              get: function() {
                return this[targetProp][prop];
              },
              set: function(val) {
                this[targetProp][prop] = val;
              }
            });
          });
        }

        function proxyRequestMethods(
          ProxyClass,
          targetProp,
          Constructor,
          properties
        ) {
          properties.forEach(function(prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function() {
              return promisifyRequestCall(this[targetProp], prop, arguments);
            };
          });
        }

        function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
          properties.forEach(function(prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function() {
              return this[targetProp][prop].apply(this[targetProp], arguments);
            };
          });
        }

        function proxyCursorRequestMethods(
          ProxyClass,
          targetProp,
          Constructor,
          properties
        ) {
          properties.forEach(function(prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function() {
              return promisifyCursorRequestCall(
                this[targetProp],
                prop,
                arguments
              );
            };
          });
        }

        function Index(index) {
          this._index = index;
        }

        proxyProperties(Index, "_index", [
          "name",
          "keyPath",
          "multiEntry",
          "unique"
        ]);

        proxyRequestMethods(Index, "_index", IDBIndex, [
          "get",
          "getKey",
          "getAll",
          "getAllKeys",
          "count"
        ]);

        proxyCursorRequestMethods(Index, "_index", IDBIndex, [
          "openCursor",
          "openKeyCursor"
        ]);

        function Cursor(cursor, request) {
          this._cursor = cursor;
          this._request = request;
        }

        proxyProperties(Cursor, "_cursor", [
          "direction",
          "key",
          "primaryKey",
          "value"
        ]);

        proxyRequestMethods(Cursor, "_cursor", IDBCursor, ["update", "delete"]);

        // proxy 'next' methods
        ["advance", "continue", "continuePrimaryKey"].forEach(function(
          methodName
        ) {
          if (!(methodName in IDBCursor.prototype)) return;
          Cursor.prototype[methodName] = function() {
            var cursor = this;
            var args = arguments;
            return Promise.resolve().then(function() {
              cursor._cursor[methodName].apply(cursor._cursor, args);
              return promisifyRequest(cursor._request).then(function(value) {
                if (!value) return;
                return new Cursor(value, cursor._request);
              });
            });
          };
        });

        function ObjectStore(store) {
          this._store = store;
        }

        ObjectStore.prototype.createIndex = function() {
          return new Index(
            this._store.createIndex.apply(this._store, arguments)
          );
        };

        ObjectStore.prototype.index = function() {
          return new Index(this._store.index.apply(this._store, arguments));
        };

        proxyProperties(ObjectStore, "_store", [
          "name",
          "keyPath",
          "indexNames",
          "autoIncrement"
        ]);

        proxyRequestMethods(ObjectStore, "_store", IDBObjectStore, [
          "put",
          "add",
          "delete",
          "clear",
          "get",
          "getAll",
          "getKey",
          "getAllKeys",
          "count"
        ]);

        proxyCursorRequestMethods(ObjectStore, "_store", IDBObjectStore, [
          "openCursor",
          "openKeyCursor"
        ]);

        proxyMethods(ObjectStore, "_store", IDBObjectStore, ["deleteIndex"]);

        function Transaction(idbTransaction) {
          this._tx = idbTransaction;
          this.complete = new Promise(function(resolve, reject) {
            idbTransaction.oncomplete = function() {
              resolve();
            };
            idbTransaction.onerror = function() {
              reject(idbTransaction.error);
            };
            idbTransaction.onabort = function() {
              reject(idbTransaction.error);
            };
          });
        }

        Transaction.prototype.objectStore = function() {
          return new ObjectStore(
            this._tx.objectStore.apply(this._tx, arguments)
          );
        };

        proxyProperties(Transaction, "_tx", ["objectStoreNames", "mode"]);

        proxyMethods(Transaction, "_tx", IDBTransaction, ["abort"]);

        function DB(db) {
          this._db = db;
        }

        DB.prototype.transaction = function() {
          return new Transaction(
            this._db.transaction.apply(this._db, arguments)
          );
        };

        proxyProperties(DB, "_db", ["name", "version", "objectStoreNames"]);

        proxyMethods(DB, "_db", IDBDatabase, ["close"]);

        // Add cursor iterators
        // TODO: remove this once browsers do the right thing with promises
        ["openCursor", "openKeyCursor"].forEach(function(funcName) {
          [ObjectStore, Index].forEach(function(Constructor) {
            // Don't create iterateKeyCursor if openKeyCursor doesn't exist.
            if (!(funcName in Constructor.prototype)) return;

            Constructor.prototype[
              funcName.replace("open", "iterate")
            ] = function() {
              var args = toArray(arguments);
              var callback = args[args.length - 1];
              var nativeObject = this._store || this._index;
              var request = nativeObject[funcName].apply(
                nativeObject,
                args.slice(0, -1)
              );
              request.onsuccess = function() {
                callback(request.result);
              };
            };
          });
        });

        // polyfill getAll
        [Index, ObjectStore].forEach(function(Constructor) {
          if (Constructor.prototype.getAll) return;
          Constructor.prototype.getAll = function(query, count) {
            var instance = this;
            var items = [];

            return new Promise(function(resolve) {
              instance.iterateCursor(query, function(cursor) {
                if (!cursor) {
                  resolve(items);
                  return;
                }
                items.push(cursor.value);

                if (count !== undefined && items.length == count) {
                  resolve(items);
                  return;
                }
                cursor.continue();
              });
            });
          };
        });

        self.DB = DB;
      })();
    </script>

    <script>
      class Database {
        constructor(db) {
          this.db = db;
        }
        // put a single value with an optional key - uses autoIncrement if no key provided - returns the key
        async put(objectStore, value, key) {
          const tx = this.transaction(objectStore, "readwrite");
          const result = await tx.objectStore(objectStore).put(value, key);
          await tx.complete;
          return result;
        }

        transaction(storeNames, transactionMode) {
          return this.db.transaction(storeNames, transactionMode);
        }
      }

      function signal() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        promise.resolve = resolve;
        promise.reject = reject;
        return promise;
      }

      const open = async name =>
        new Promise((resolve, reject) => {
          const request = indexedDB.open(name, 1);
          request.onerror = reject;
          request.onsuccess = e => resolve(e.target.result);
          request.onupgradeneeded = e => {
            const db = e.target.result;
            const store = db.createObjectStore(STORE_NAME, {
              autoIncrement: true
            });
            store.transaction.oncomplete = () => {
              resolve(db);
            };
            store.transaction.onerror = reject;
          };
        });

      const deleteIdb = async name =>
        new Promise((resolve, reject) => {
          console.log("deleting...");
          const request = indexedDB.deleteDatabase(name);
          request.onerror = reject;
          request.onsuccess = resolve;
          request.onblocked = reject;
        });

      const STORE_NAME = "store";

      window.tableflowDone = signal();

      (async () => {
        await Promise.all([
          (async () => {
            const databases = await window.indexedDB.databases();
            for (const { name } of databases) {
              if (name.startsWith("a")) {
                await deleteIdb(name);
              }
            }
            const aDbName = `a-${Math.floor(Math.random() * 10000000)}`;
            const db = await open(aDbName);
            const aDb = new Database(new DB(db));
            for (const _ of new Array(5 /* 0.5Mb */).fill(null)) {
              const message = new Uint8Array(1e5 /* 0.1Mb */).map(
                _ => Math.random() * 1000
              );
              await aDb.put(STORE_NAME, message);
            }

            window.tableflowDone.resolve();
            const tx = aDb.transaction([STORE_NAME]);
            const store = tx.objectStore(STORE_NAME);
            store.iterateCursor(cursor => {
              if (!cursor) {
                return;
              }
              cursor.continue();
            });
            await tx.complete;
          })(),
          (async () => {
            await window.tableflowDone;
            const databases = await window.indexedDB.databases();
            for (const { name } of databases) {
              if (name.startsWith("b")) {
                await deleteIdb(name);
              }
            }
            const bDbName = `b-${Math.floor(Math.random() * 10000000)}`;
            const db = await open(bDbName);
            const bDb = new Database(new DB(db));

            for (const _ of new Array(50 /* 50Mb */).fill(null)) {
              const message = new Uint8Array(1e6 /* 1Mb */).map(
                _ => Math.random() * 1000
              );
              await bDb.put(STORE_NAME, message);
            }
          })()
        ]);

        if (!navigator || !navigator.storage || !navigator.storage.estimate) {
          throw new Error(
            "navigator.storage.estimate not supported; this repro only supports the latest version of Google Chrome"
          );
        }
        const estimate = await navigator.storage.estimate();
        const indexedDB = estimate.usageDetails.indexedDB;

        console.log("Done");

        document.body.innerText = `Total db size: ${indexedDB / 1e6}Mb`;
      })();
    </script>
  </body>
</html>
