<!DOCTYPE html>
<html>
  <body>
    <script>
      "use strict";

      (function() {
        function toArray(arr) {
          return Array.prototype.slice.call(arr);
        }

        function promisifyRequest(request) {
          return new Promise(function(resolve, reject) {
            request.onsuccess = function() {
              resolve(request.result);
            };

            request.onerror = function() {
              reject(request.error);
            };
          });
        }

        function promisifyRequestCall(obj, method, args) {
          var request;
          var p = new Promise(function(resolve, reject) {
            request = obj[method].apply(obj, args);
            promisifyRequest(request).then(resolve, reject);
          });

          p.request = request;
          return p;
        }

        function promisifyCursorRequestCall(obj, method, args) {
          var p = promisifyRequestCall(obj, method, args);
          return p.then(function(value) {
            if (!value) return;
            return new Cursor(value, p.request);
          });
        }

        function proxyProperties(ProxyClass, targetProp, properties) {
          properties.forEach(function(prop) {
            Object.defineProperty(ProxyClass.prototype, prop, {
              get: function() {
                return this[targetProp][prop];
              },
              set: function(val) {
                this[targetProp][prop] = val;
              }
            });
          });
        }

        function proxyRequestMethods(
          ProxyClass,
          targetProp,
          Constructor,
          properties
        ) {
          properties.forEach(function(prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function() {
              return promisifyRequestCall(this[targetProp], prop, arguments);
            };
          });
        }

        function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
          properties.forEach(function(prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function() {
              return this[targetProp][prop].apply(this[targetProp], arguments);
            };
          });
        }

        function proxyCursorRequestMethods(
          ProxyClass,
          targetProp,
          Constructor,
          properties
        ) {
          properties.forEach(function(prop) {
            if (!(prop in Constructor.prototype)) return;
            ProxyClass.prototype[prop] = function() {
              return promisifyCursorRequestCall(
                this[targetProp],
                prop,
                arguments
              );
            };
          });
        }

        function Cursor(cursor, request) {
          this._cursor = cursor;
          this._request = request;
        }

        proxyProperties(Cursor, "_cursor", [
          "direction",
          "key",
          "primaryKey",
          "value"
        ]);

        proxyRequestMethods(Cursor, "_cursor", IDBCursor, ["update", "delete"]);

        // proxy 'next' methods
        ["advance", "continue", "continuePrimaryKey"].forEach(function(
          methodName
        ) {
          if (!(methodName in IDBCursor.prototype)) return;
          Cursor.prototype[methodName] = function() {
            var cursor = this;
            var args = arguments;
            return Promise.resolve().then(function() {
              cursor._cursor[methodName].apply(cursor._cursor, args);
              return promisifyRequest(cursor._request).then(function(value) {
                if (!value) return;
                return new Cursor(value, cursor._request);
              });
            });
          };
        });

        function ObjectStore(store) {
          this._store = store;
        }

        proxyCursorRequestMethods(ObjectStore, "_store", IDBObjectStore, [
          "openCursor"
        ]);

        (function() {
          // Don't create iterateKeyCursor if openKeyCursor doesn't exist.
          if (!("openCursor" in ObjectStore.prototype)) return;

          ObjectStore.prototype["iterateCursor"] = function() {
            var args = toArray(arguments);
            var callback = args[args.length - 1];
            var nativeObject = this._store || this._index;
            var request = nativeObject["openCursor"].apply(
              nativeObject,
              args.slice(0, -1)
            );
            request.onsuccess = function() {
              callback(request.result);
            };
          };
        })();

        function Transaction(idbTransaction) {
          this._tx = idbTransaction;
          this.complete = new Promise(function(resolve, reject) {
            idbTransaction.oncomplete = function() {
              resolve();
            };
            idbTransaction.onerror = function() {
              reject(idbTransaction.error);
            };
            idbTransaction.onabort = function() {
              reject(idbTransaction.error);
            };
          });
        }

        Transaction.prototype.objectStore = function() {
          return new ObjectStore(
            this._tx.objectStore.apply(this._tx, arguments)
          );
        };

        proxyProperties(Transaction, "_tx", ["objectStoreNames", "mode"]);

        proxyMethods(Transaction, "_tx", IDBTransaction, ["abort"]);

        function DB(db) {
          this._db = db;
        }

        DB.prototype.transaction = function() {
          return new Transaction(
            this._db.transaction.apply(this._db, arguments)
          );
        };

        self.DB = DB;
      })();
    </script>

    <script>
      function signal() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        promise.resolve = resolve;
        promise.reject = reject;
        return promise;
      }

      const open = async name =>
        new Promise((resolve, reject) => {
          const request = indexedDB.open(name, 1);
          request.onerror = reject;
          request.onsuccess = e => resolve(e.target.result);
          request.onupgradeneeded = e => {
            const db = e.target.result;
            const store = db.createObjectStore(STORE_NAME, {
              autoIncrement: true
            });
            store.transaction.oncomplete = () => {
              resolve(db);
            };
            store.transaction.onerror = reject;
          };
        });

      const deleteIdb = async name =>
        new Promise((resolve, reject) => {
          console.log("deleting...");
          const request = indexedDB.deleteDatabase(name);
          request.onerror = reject;
          request.onsuccess = resolve;
          request.onblocked = reject;
        });

      const fill = async (db, mb) =>
        new Promise(async (resolve, reject) => {
          const tx = db.transaction(STORE_NAME, "readwrite");
          tx.oncomplete = resolve;
          tx.onerror = reject;
          const store = tx.objectStore(STORE_NAME);
          for (let i = 0; i < mb; i++) {
            const request = store.add({
              data: new Uint8Array(1e6).map(_ => Math.random() * 1000) /* 1Mb */
            });
            request.onerror = reject;
          }
        });

      const STORE_NAME = "store";

      window.tableflowDone = signal();

      (async () => {
        await Promise.all([
          (async () => {
            const databases = await window.indexedDB.databases();
            for (const { name } of databases) {
              if (name.startsWith("a")) {
                await deleteIdb(name);
              }
            }
            const aDbName = `a-${Math.floor(Math.random() * 10000000)}`;
            const db = await open(aDbName);
            const aDb = new DB(db);
            await fill(db, 5 /* Mb */);

            window.tableflowDone.resolve();
            const tx = aDb.transaction([STORE_NAME]);
            const store = tx.objectStore(STORE_NAME);
            store.iterateCursor(cursor => {
              if (!cursor) {
                return;
              }
              cursor.continue();
            });
            await tx.complete;
          })(),
          (async () => {
            await window.tableflowDone;
            const databases = await window.indexedDB.databases();
            for (const { name } of databases) {
              if (name.startsWith("b")) {
                await deleteIdb(name);
              }
            }
            const bDbName = `b-${Math.floor(Math.random() * 10000000)}`;
            const db = await open(bDbName);
            await fill(db, 50 /* Mb */);
          })()
        ]);

        if (!navigator || !navigator.storage || !navigator.storage.estimate) {
          throw new Error(
            "navigator.storage.estimate not supported; this repro only supports the latest version of Google Chrome"
          );
        }
        const estimate = await navigator.storage.estimate();
        const indexedDB = estimate.usageDetails.indexedDB;

        console.log("Done");

        document.body.innerText = `Total db size: ${indexedDB / 1e6}Mb`;
      })();
    </script>
  </body>
</html>
